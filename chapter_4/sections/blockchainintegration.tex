\section{Integration von Blockchain}
\label{sec:blockchainintegration}


\subsection{Auswahl der Blockchain}
Für die Integration der Blockchain in das Protokoll wurde zunächst eine geeignete Blockchain gesucht. Dabei wurde sich auf die beiden bekanntesten Blockchains, Bitcoin und Ethereum, beschränkt. Da Bitcoin eine reine Kryptowährung ist und keine Smart Contracts unterstützt, wurde sich für Ethereum entschieden. Ethereum ist eine Blockchain, die zwar auch eine Kryptowährung, Ether, besitzt, aber zusätzlich auch Smart Contracts unterstützt. Der Grund für die Existenz einer Währung auf der Blockchain ist, dass die Smart Contracts, die auf der Blockchain ausgeführt werden, mit Ether bezahlt werden müssen \parencite[S. 2]{Antonopoulos_MasteringEthereum}. Das bedeutet für die Teilnehmer des Protokolls, dass sie Ether besitzen müssen, um sich registrieren zu können. Für die zwei weiteren Funktionen, die die Blockchain im Protokoll übernimmt, ist keine Währung notwendig, da es sich um reine Lesezugriffe handelt, welche keine Kosten verursachen. Die beiden Funktionen sind die Suche nach einem Benutzernamen und die Suche nach einem öffentlichen Schlüssel anhand eines Benutzernamens. Diese beiden Funktionen werden in Abschnitt \ref{subsec:contract_registrierung} (\nameref{subsec:contract_kommunikation}) und Abschnitt \ref{subsec:kommunikation} (\nameref{subsec:kommunikation}) beschrieben. Die Blockchain wird also nur für die Registrierung der Teilnehmer und für die Suche nach Benutzernamen und öffentlichen Schlüsseln verwendet.


\subsection{Registrierung}
\label{subsec:contract_registrierung}
Um das Protokoll zu nutzen, muss sich jeder Nutzer zunächst auf der Blockchain registrieren. Dazu muss ein Smart Contract auf der Blockchain ausgeführt werden, der die Registrierung des Nutzers durchführt. Dieser Smart Contract wird mit dem Benutzernamen und dem statischen öffentlichen Schlüssel aufgerufen. Der statische öffentliche Schlüssel wird bei der Registrierung, bevor der Smart Contract angestoßen wird, festgelegt und kann nicht mehr geändert werden. Der Smart Contract erstellt einen neuen Eintrag in der Blockchain, der den Benutzernamen und den öffentlichen Schlüssel des Nutzers enthält. Um Dopplungen in der Blockchain zu vermeiden, wird der Benutzername nicht als Key in der Blockchain gespeichert, sondern als Value. Als Key wird die Adresse des Benutzers verwendet. Dadurch wird sichergestellt, dass jeder Benutzer nur einmal auf der Blockchain registriert werden kann. Diese Funktion wird nur einmalig bei der Registrierung aufgerufen. Sollte ein Nutzer seinen Benutzernamen ändern wollen, muss er sich mit dem neuen Benutzernamen und dem öffentlichen Schlüssel eines neu erzeugten statischen Schlüsselpaars erneut registrieren. Die Funktion im Smart Contract könnte wie folgt aussehen:

\begin{lstlisting}[language=Solidity, caption={Registrierung eines Nutzers auf der Blockchain},captionpos=b]
// Function to register a user
function registerUser(string memory _username, 
    bytes memory _publicKey) external {
        // Check if the username and public key are not empty
        require(bytes(_username).length > 0, 
            "Username cannot be empty");
        require(_publicKey.length > 0, 
            "Public key cannot be empty");

        // Check if the username is not already taken
        require(usernames[_username] == address(0), 
            "Username is already taken");

        // Check if the user is not already registered
        require(!users[msg.sender].isRegistered, "User is already registered");

        // Add the user to the users mapping with the user's 
        // username as the key
        users[msg.sender] = User(_username, _publicKey, true);

        // Store the username to address mapping
        usernames[_username] = msg.sender;

        // Emit the UserRegistered event with the user's address, 
        // username and public key
        emit UserRegistered(msg.sender, _username, _publicKey);
}
\end{lstlisting}


\subsection{Kommunikation}
\label{subsec:contract_kommunikation}
Für die Kommunikation mit anderen Teilnehmern, benötigt man die ID des anderen Teilnehmers im Kademlia-Netzwerk. Da die ID im Kademlia-Netzwerk dem Benutzernamen entspricht, muss der Benutzername des anderen Teilnehmers bekannt sein. Dazu wird dieser Benutzername auf der Blockchain gesucht, um zu kontrollieren, ob dieser bereits registriert ist. Hierfür wird eine Funktion im Smart Contract auf der Blockchain aufgerufen, die den Benutzernamen als Parameter erhält. Der Smart Contract sucht dann in der Blockchain nach dem Benutzernamen und gibt ihn, falls vorhanden, zurück. Sollte kein Benutzer mit diesem Benutzernamen auf der Blockchain vorhanden sein, wird ein leerer String zurückgegeben, der darauf hinweist, dass der gesuchte Benutzer nicht registriert ist und somit keine Verbindung aufgebaut werden kann. Der Rückgabewert muss von der Applikation, die dieses Protokoll nutzt, abgefangen werden. 
Die Funktion könnte wie folgt aussehen:

\begin{lstlisting}[language=Solidity, caption={Suche nach einem Benutzernamen auf der Blockchain},captionpos=b]
// Function to verify a user's username
function verifyUsername(string memory _username) external view 
    returns (string memory) {
        // Try to get the address associated with the username
        address userAddress = usernames[_username];

        // Check if the address is empty
        require(userAddress != address(0), 
            "User does not exist.");

        // Get the user's details
        User storage user = users[userAddress];

        // Return the user's username
        return (user.username);
}
\end{lstlisting}


\noindent Ist der Benutzername auf der Blockchain vorhanden und es kommt zum Verbindungsaufbau wie in Abschnitt \ref{subsec:verbindungsmanagement} (\nameref{subsec:verbindungsmanagement}) beschrieben, wird der öffentliche Schlüssel des Benutzers ausgelesen. Dafür wird die nachstehende Funktion genutzt:

\begin{lstlisting}[language=Solidity, caption={Suche nach einem öffentlichen Schlüssel auf der Blockchain},captionpos=b]
// Function to get a user's public key
function getUserPublicKey(string memory _username) external view 
    returns (bytes memory) {
        // Try to get the address associated with the username
        address userAddress = usernames[_username];

        // Check if the address is empty
        require(userAddress != address(0), 
            "User does not exist.");

        // If the address is not empty, get the user 
        // details using the address
        User storage user = users[userAddress];

        // Return the user's public key
        return (user.publicKey);
}
\end{lstlisting}

\noindent Um Redundanz im Code zu vermeiden, wäre es sinnvoll das Suchen nach der Adresse des übergebenen Benutzernamens, die Prüfung ob die Adresse leer ist und das Auslesen der Benutzerdaten aus dem Mapping in eine eigene Funktion auszulagern, welche nur von innerhalb des Smart Contracts aufgerufen werden kann. Aus Gründen des besseren Lese- und Verständnisflusses wurde dies hier nicht umgesetzt.

Durch das Speichern des öffentlichen Schlüssels auf der Blockchain kann jeder Teilnehmer die öffentlichen Schlüssel der anderen Teilnehmer finden und die Nachrichten, die er erhält, mit dem öffentlichen Schlüssel des Absenders verifizieren. Dadurch kann sichergestellt werden, dass die Nachrichten tatsächlich vom angegebenen Absender stammen und nicht von einem anderen Teilnehmer gesendet wurden, der sich als jemand anderes ausgibt.

% #TODO: maybe add JavaScript code for the function calls (only if I need more pages)

